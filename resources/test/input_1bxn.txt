# Example showing how to use TEM-simulator
#
# This file is an example of input for TEM-simulator. The comments below
# explain the meaning of the various input parameters. Besides this input
# file, the PDB file 2OM3.pdb and the text files 2OM3_transf.txt and 
# TMV_coord.txt are required as input to the simulation.
# 
# To run the simulation, execute the command
# <path to executable>/TEM-simulator input.txt
# The simulation takes a few minutes to run.
#
# This simulation sets up a sample containing three small pieces of Tobacco
# Mosaic Virus, in different orientations, and simulates a tilt series of
# 61 images as the sample is rotated around a single axis.
#
# The input split is into different components. Lines starting with an = sign 
# mark the beginning of a component. In each component, values are assigned
# to certain parameters. The order of the components, and the order of 
# parameter assignments within each component, is unimportant.

=== simulation ===

# The simulation component specifies what kind of computations should be done.
# These input parameters indicate that a set of micrographs should be 
# generated.

generate_micrographs = yes

# A log file is saved showing all input parameters and which steps of the
# simulation have been completed. The format of the log file is such that
# it can be used as input in another simulation.

log_file = simulator.log

=== sample ===

# The sample component specifies the overall shape of the sample. The sample 
# consists of a number of particles embedded in ice and sits in a circular 
# hole in a supporting film. The diameter of the hole and the thickness of 
# the ice at the center and at the edge of the hole are given in nanometer.

diameter = 1000
thickness_edge = 125
thickness_center = 125

=== particle TMV ===

# A particle component specifies a kind of particle to be placed in the sample.
# The particle used in this simulation in a small part of a Tobacco Mosaic Virus
# whose structure is obtained from a PDB file.
#
# The source of the particle structure is a PDB file. Other possibilities are 
# reading a volume map (for example an MRC file) or generating a random shape.

source = pdb
pdb_file_in = 1BXN.pdb

# The PDB file specifies the structure of one subunit building up the virus.
# The following file specifies a number of transformations which are applied 
# to this subunit to obtain a bigger piece of the virus. The data were taken
# from lines 154-300 of the PDB file.

pdb_transf_file_in = 1bxn_transf.txt

# The PDB file is first converted into a volume map of the electrostatic potential
# in the molecule. The size of the voxels in this map is set to 0.1 nm.

voxel_size = 0.1

# The volume maps are saved to MRC files. This is not really necessary for the
# present simulation, but these files can be reused in subsequent simulations
# to save computational time.

map_file_re_out = 2OM3_map.mrc
map_file_im_out = 2OM3_abs_map.mrc

=== particleset ===

# A particleset component specifies the placement of a number of identical particles 
# in the sample. In this simulation, three copies of the TMV fragment are places in
# different orientations. Their positions and orientation are determined by the
# file TMV_coord.txt

particle_type = TMV
num_particles = 3
particle_coords = file
coord_file_in = TMV_coord.txt

=== geometry ===

# The geometry component specifies how the sample is rotated in each image 
# of the tilt series.
#
# A simple tilt series with rotations around a single axis can be specified
# by the parameters tilt_axis, theta_start and theta_incr.
# More complicated tilt series can be generated by reading the Euler angles of 
# each image from a file instead.

gen_tilt_data = yes

# The tilt series has 61 images. The tilt angle starts at -60 degrees
# and increases 2 degrees between each image. By default, the x-axis is
# used as tilt axis. This can be changed by assigning the parameter tilt_axis.

ntilts = 61
theta_start = -60
theta_incr = 2

# It is possible to include various errors in the tilt angles and the alignment.
# The errors can either be generated randomly or read from a text file. In this 
# simulation no geometry errors are used.

geom_errors = none

=== electronbeam ===

# The electronbeam component specifies the properties of the electron beam.
#
# In this simulation the acceleration voltage is 200 kV and the energy spread 
# of the beam is 1.3 eV.

acc_voltage = 300
energy_spread = 1.3 # ASK SEBASTIAN

# In this simulation, the electron dose in each image is generated from a few
# parameters. The total dose of 6000 electrons per square nanometer is equally
# distributed over all the images.

gen_dose = yes
total_dose = 15000

=== optics ===

# The optics component specifies the properties of the optical system.
#
# The magnification is 30000 times. The spherical aberration cs, and the
# chromatic aberration cc are in mm. The diameter of the aperture in the
# focal plane is in micrometer, and the focal length of the primary lens
# is in mm. The aperture angle of the condenser lens is in milliradian.

magnification = 81000
cs = 2.7
cc = 2
aperture = 50
focal_length = 3
cond_ap_angle = 0.1

# In this simulation all the images are at the same defocus. Defocus is 
# given i micrometer, and positive values means underfocus.

gen_defocus = yes
defocus_nominal = 5

=== detector ===

# A specification of the detector is the last component needed to simulate 
# micrographs.
#
# Here a 400 x 400 pixel detector area is simulated.

det_pix_x = 1024
det_pix_y = 1024

# The physical size of the detector pixels is 16 micrometer.

pixel_size = 15

# The gain is the average number of counts in the readout generated by each 
# electron that strikes the detector. Changing the gain does not change the
# quality of the images, but can be useful to mimic the output from a particular
# real detector.

gain = 10

# A realistic simulation should use quantization of the electron detection, as
# this is the dominating source of noise in real micrographs. Removing this 
# source of noise can sometimes be useful, for example to check that the 
# simulation is set up correctly.

use_quantization = yes

# The detector quantum efficiency is a number between 0 and 1. An ideal detector
# would have DQE = 1.

dqe = 0.4

# The MTF parameters control the blurring of the image as it is transferred from
# the scintillator to the actual detector, such as a CCD.

mtf_a = 0.7
mtf_b = 0.2
mtf_c = 0.1
mtf_alpha = 10
mtf_beta = 40

# The images are all written to a single MRC file called tiltseries.mrc

image_file_out = tiltseries.mrc

=== detector ===

# For reference, it is useful to also save a second series of unrealistically
# noise free images. This can be accomplished by using a second detector 
# component with use_quantization set to no.

det_pix_x = 1024
det_pix_y = 1024
pixel_size = 15
gain = 10
use_quantization = no
dqe = 0.4
mtf_a = 0.7
mtf_b = 0.2
mtf_c = 0.1
mtf_alpha = 10
mtf_beta = 40
image_file_out = tiltseries_nonoise.mrc

